# 一、操作系统概论

## 1.1操作系统概述

### 1.1.1 操作系统与计算机系统

**计算机系统分为哪四层？从上向下看**

> 1. 应用程序层：**解决用户不同的应用问题**
> 2. 支撑软件层：**建立在操作系统改造和扩充过的机器上**，提供扩展指令集，实现各种语言处理程序、数据库管理系统和其他系统程序。
> 3. 系统软件层：**最靠近硬件的一层软件**
> 4. 计算机硬件层：**操作系统赖以工作的基础**，也是操作系统设计者可以使用的功能和资源

**系统软件与支撑、应用软件的区别？**

> 应用软件：基于用户需求编写、安装的专用程序
>
> 支撑软件：实用程序、语言处理程序、数据库管理系统
>
> 系统软件：操作系统
>
> 操作系统与支撑、应用软件层次的区别：1、操作系统有权分配物理硬件资源。2、其它上层软件只能通过操作系统来使用资源
>
> 操作系统用于隔离硬件与其它上层软件

**冯·诺伊曼体系结构包括哪几个部分？**

> 0vo
>

**操作系统的主要任务？分为几大任务？**

> <img src="https://gitee.com/cpicture/picture-1/raw/master/202109171948621.png" style="zoom:67%;" />

### 1.1.2 操作系统的资源管理技术

**操作系统资源管理的主要技术包括？**

> **复用：**多个进程共享有限的物理资源
>
> **虚拟：**把一个物理资源变成多个逻辑对应物
>
> **抽象：**屏蔽资源复杂性，提高资源易用性

**资源复用分为哪两种？试举例说明**

> - 空分复用：资源可以从空间上分割成更小的单元进行使用(内存/硬盘被划分成不同的单元/区域)
> - 时分复用：从时间上进行分割，形成时间片，确保在单一时间片内，进程对资源是独占的；中断、抢占、调度算法

**多道程序设计：**多个进程共享硬件的技术

**什么是虚拟化?试举例说明**

> 对资源进行转化、模拟或整合,把一个物理资源转变为逻辑上的多个对应物

**什么是抽象？试举例说明**

> **抽象：**屏蔽资源复杂性，提高资源易用性
>
> 通过创建软件来屏蔽硬件资源的物理特性和接口细节
>
> 简化对硬件资源的操作、控制和使用
>
> 不考虑物理细节对资源执行操作
>
> 虚拟和复用比较：
>
> 1. 复用分割实际存在的物理资源，解决**有限资源利用不充分**的问题
> 2. 虚拟创建假想的逻辑同类资源，解决**有限资源不足**的问题

**试列举说明组合使用资源管理的例子？**

> 往往同时实施抽象和虚化技术
>
> 打印机：打印函数和虚拟多个设备|显示器

**操作系统的基础抽象包括哪三种**？

> 进程抽象：虚存抽象：文件抽象：
>
> 进程的执行依赖对存储的抽象
>
> 虚存的管理又依赖对文件的抽象

**操作系统的其它抽象？举例**

> 对其他低层硬件资源也进行抽象
>
> 中断、时钟、网络接口
>
> 一些没有特定基础硬件的软件资源也可被抽象
>
> 消息、信号量、共享数据结构

**操作系统担任的两项基本任务**

> 防止硬件资源被失控的应用程序滥用
>
> 屏蔽复杂的硬件操作细节

### 1.1.3 操作系统定义和作用

**操作系统定义？**

> 1.管理系统资源
>
> 2.控制程序执行
>
> 3.改善人机界面
>
> 4.提供各种（系统调用）服务
>
> 5.合理组织计算机工作流程
>
> 6.为用户方便有效使用计算机提供良好运行环境

**四种常用观点来看待操作系统的作用**？

> 系统实现观点
>
> 资源管理观点
>
> 进程交互观点
>
> 服务用户观点

### 1.1.4 操作系统功能和特性

**操作系统的五大功能？**

> 网络与通信管理

**操作系统的三大特性**？

> 

**什么是并发性？和并行性的区别？**

> 并发性：指两个或两个以上的事件或活动在**同一时间间隔**内发生
>
> 并行性（parallelism）：指两个或两个以上事件或活动在==同一时刻==发生
>
> 并发性的实质：有限个物理CPU在若干道程序之间实现多路复用，在多用户（/进程）间共享以提高资源利用率

什么是共享性？

> 操作系统中的资源（包括硬件资源和信息资源）可被多个并发执行的进程共同使用，而不是被其中某一个程序所独占
>
> 透明资源共享：每个进程独占完整的虚拟机，时分复用处理器，空分复用存储器，资源隔离和授权访问问题
>
> 独占资源共享：同一时间内只允许一个程序访问临界资源，需要互斥或同步访问

**什么是异步性？**

> 随机性、不确定性
>
> 多道程序环境中，多个进程的并发活动导致随机事件发生
>
> 只要运行环境相同，多次运行统一程序，得到的结果完全

## 1.2操作系统形成与发展

### 1.2.1 人工操作阶段

作业和程序的区别

> 一个进程是一个程序对某个数据集的执行过程。
>
> 一个作业是用户需要计算机完成的某项任务，是要求计算机所做工作的集合。一个作业中至少包含一个程序。

**人工操作阶段面临的问题？**

> 用户独占全机资源，资源利用率不高
>
> 代码维护困难，手工操作多，浪费处理机时间
>
> 数据的输入，程序的执行、结果的输出均联机进行，从上机到下机的时间拉得非常长

### 1.2.2执行操作系统

**引入作业执行系统来自动完成作业流程**

**联机I/O技术**

**脱机I/O技术**

### 1.2.3多道程序设计与操作系统形成

多道程序技术：允许多个程序同时进入主存储器并交替计算的方法。即计算机内存中同时存放了多道程序，它们都处于开始和结束点之间

多道程序技术离不开中断和通道技术的发展。

> 中断：避免CPU因不断轮询设备而浪费时间
>
> 通道：专门负责I/O的独立处理器，减轻CPU的处理压力

**多道程序设计利弊**

> 提高了CPU的利用率、提高了内存和I/O设备的利用率、提高了系统的吞吐率、充分发挥了系统的并行性
>
> 每单道程序延长了计算时间、延长了作业周转时间、牺牲了用户的响应时间

CPU利用率计算：1-p^n^

道数的影响因素：I/O 等待时间、内存容量、用户等待时间

### 1.2.4操作系统的发展和分类

**批处理系统**：批量化处理作业方式的操作系统

> 用户脱机工作、成批处理作业、单/多个程序运行

**分时操作系统**：允许多个联机用户同时使用一台计算机系统操作系统

**实时操作系统**

## 1.3操作系统基础服务与用户接口

**操作系统通过什么方式向用户提供服务**？

> 程序接口和操作接口

**程序接口**：由一组系统调用（System Call)）组成，用户程序使用“系统调用”就可获得操作系统的底层服务；使用或访问系统的各种软硬件资源

**操作接口**：为用户操作控制计算机工作和提供服务的手段的集合，通常有操作控制命令、图形操作界面、批处理系统提供的作业控制语言(命令)等

**系统调用与机器指令的区别**

> 机器指令由硬件实现
>
> 系统调用是由操作系统在机器指令的基础上实现的过程或子程序

**内核态**：管态、核心态。运行在该模式的代码，可以无限制地对系统存储、外部设备进行访问。程序受硬件保护，用户不能随意篡改内容。

**用户态**：目态、普通态。执行的代码被硬件限定，不能进行例如写入其他进程的存储空间这样的操作。

**系统调用作用：**

> 所有进程只能通过系统调用访问系统资源，由内核基于权限提供一致性规划对资源访问进行裁决，保证系统的安全性
>
> 系统资源调用方法进行抽象，提供一致接口，避免面户在使用资源时发生错误，提高编程效率

**系统调用参数传递**

<img src="https://gitee.com/cpicture/picture-1/raw/master/202112090956406.png" alt="image-20211209095558267" style="zoom: 80%;" />

**系统调用与函数调用的区别**

> 调用形式不同,函数调用所转向的地址固定不变，系统调用不包含内核服务例程入口地址
>
> 被调用代码的位置不同，调用程序和调用代码在同一程序，函数升级或修改需要重新编译，
>
> 提供方式不同，函数调用编译语言
>
> 调用实现不同
>
> ![image-20211209101931319](https://gitee.com/cpicture/picture-1/raw/master/202112091019410.png)
>
> ![image-20211209101944020](https://gitee.com/cpicture/picture-1/raw/master/202112091019076.png)

**有哪两类作业级接口**

> 联机作业控制接口：交互性作业处理
>
> 脱机作业控制接口：批作业处理

**什么叫做命令解释程序**

> 接收用户指令并解释执行指令

**什么叫做系统程序**

> 不属于操作系统的核心，但为用户程序的开发、调试、执行、和维护解决带有共性的问题或执行公共操作

## 1.4结构和运行模型

**操作系统设计呈现出特征**？

> 复杂程度高、生成周期长、正确性难保证

内核不是进程，而是支持系统运行基本功能的一组**程序模块**。内核对硬件处理器及有关资源进行首次改造，以便给进程的执行提供良好的运行环境

11、**微内核和单内核**？

> ![image-20211209113629148](https://gitee.com/cpicture/picture-1/raw/master/202112091136205.png)

**内核的功能**

> 中断处理：缩短屏蔽中断的时间，增加系统内的并发性
>
> 时钟管理：时间片调度，定时唤醒
>
> 短程管理：分配处理器、处理器转让、保护恢复现场
>
> 原语管理：原语由内核完成

12、操作系统的整体结构

13、操作系统的局部结构

14、操作系统的运行模型

> ![image-20211209114119958](https://gitee.com/cpicture/picture-1/raw/master/202112091141019.png)

15、单体式结构？缺点和优点

> 以功能模块为操作系统的基本单元

16、层次式结构？缺点和优点

> 把操作系统划分为内核和模块（进程）
>
> 模块按功能调用次序排序成层次

17、虚拟机结构？缺点和优点

> 将一台物理计算机虚拟成了若干台逻辑计算机，而且每个虚拟计算机可以运行不同的操作系统，每个操作系统上又可并发运行多道程序
>
> 进程其实并不直接运行在虚拟计算机上，而是运行在虚拟计算机上运行的操作系统上，从而不同进程赖以运行的内核（平台）可以不相同

18、微内核结构？缺点和优点

> 封装所有应用必需的核心功能，形成微内核（microkernel）
>
> 其它功能形成运行在用户态的服务进程。
>
> ![image-20211209115142969](https://gitee.com/cpicture/picture-1/raw/master/202112091151017.png)
>
> ![image-20211209115127649](https://gitee.com/cpicture/picture-1/raw/master/202112091151706.png)

# 二、处理器管理

## 2.1处理器状态

**指令系统：机器指令的集合**

> 数据处理、转移jmp、数据传送、移位、字符串、I/O类

多道程序设计环境下，从**资源管理和控制程序**执行的角度出发，必须把指令系统中的指令分作两部分：

> 特权指令：仅在内核态下才能执行的指令
>
> 非特权指令

> 内核态：可执行全部机器指令，访问所有内存单元、系统资源，改变处理器状态
>
> 用户态：执行非特权指令，访问进程内地址单元，防止操作系统程序和其它用户程序受到侵害

![image-20211209121201044](https://gitee.com/cpicture/picture-1/raw/master/202112091212100.png)

**程序状态字：**区别不同处理器的工作状态

![image-20211209121332349](https://gitee.com/cpicture/picture-1/raw/master/202112091213404.png)

## 2.2中断技术

**中断**：是指程序执行过程中，当发生某个事件时，中止CPU上现行程序的运行，引出处理该事件的程序执行的过程

**中断源分类**：

按中断事件性质和激活方式：强迫性中断/自愿性中断

按中断事件来源和实现手段：硬中断(外中断/内中断)、软中断

**硬中断：**由硬件设施来产生的中断请求

> 外中断：异步中断，来自处理器和主存之外
>
> 内中断：同步中断，来自处理器内部，不可屏蔽

外中断与内中断的区别

> 外中断是由与现行指令无关的中断信号触发
>
> 异常是由处理器控制单元产生，源于现行程序执行指令过程中检测到例外
>
> 1. 异常与CPU是同步的
> 2. 一条指令执行期间允许响应异常，而且允许多次响应异常
> 3. 异常处理程序提供的服务是为当前进程所用的
> 4. 异常会嵌套中断，但中断不会嵌套异常
> 5. 大部分**异常**发生在用户态，外中断与cpu模式无关

**中断和异常的响应及服务**

所有计算机系统都采用硬件和软件（硬件中断装置和软件中断处理程序）结合的方法实现中断处理

**中断：硬件故障中断、IO中断事件、时钟中断**

**异常：**

**程序性中断**：•语法错误、逻辑错误、程序运行过程中所产生的异常

**访问中断**

**中断优先级和多重中断**

## 2.3进程及其实现

**进程是由程序和数据两部分组成的**

**进程**：对正在运行的程序的抽象

> **进程**是一个可并发执行的具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的**基本单位**

**可再入程序**：能被多个程序同时调用；纯代码，执行中自身不会改变

**可再用程序**：被调用的过程中自身会被修改，在调用它的程序退出之前不允许其他程序来调用它

**进程的属性**：

> 结构性：每个进程至少包含三个组成元素：程序块、数据块和进程控制块
>
> 共享性：共享某些公用变量
>
> 动态性：进程由创建而产生，由调度而执行，由撤销而消亡
>
> 独立性：进程是系统中资源分配和保护的基本单位，也是系统调度的独立单位（单线程进程）
>
> 制约性：并发进程之间存在着制约关系，进程在进行的关键点上需要相互等待或互通消息，以保证程序执行的可再现性和计算结果的唯一性
>
> 并发性：在一个单处理器系统环境下，各个进程轮流占用处理器

**三态模型**

![image-20211209163601452](https://gitee.com/cpicture/picture-1/raw/master/202112091636577.png)

五态模型

![image-20211209163720033](https://gitee.com/cpicture/picture-1/raw/master/202112091637091.png)

七态模型

![image-20211209163806331](https://gitee.com/cpicture/picture-1/raw/master/202112091638386.png)

某时刻进程的内容及其状态集合称为进程映像，主要包括：

> 进程程序块：即被执行的程序，规定了进程一次运行应完成的功能。
>
> 进程数据块：即程序运行时加工处理的对象，
>
> 核心栈：每一个进程都将捆绑一个系统/用户堆栈，用来保存中断/异常现场，保存在函数调用的参数和返回地址

进程内存映像的四大基本要素：

> 程序块
>
> 堆栈块
>
> 数据块
>
> 进程控制块 PCB

进程上下文：用户级、系统级PCB、寄存器上下文PSW

进程控制块：进程的控制信息、现场信息、控制信息

将处于同一状态的所有PCB链接在一起的数据结构称为进程队列(Process Queue**s**)

队列的组织方式：线性方式、链接方式、索引方式

进程切换：

处理器模式切换：

进程控制和管理是由操作系统中的原语来实现的

**原语：**原语是机器指令的延伸，往往是为完成某些特定的功能而编制的一段系统程序。原语和机器指令类似，其特点是执行过程中**不允许被中断**，是一个**不可分割**的基本单位，原语的**执行是顺序的**而不可能是并发的

**原语vs系统调用**

> 调用形式相同：原语和系统调用都使用访管指令实现
>
> 实现方式不同：原语由内核实现，系统调用通常由系统进程或系统服务器实现
>
> 运行方式不同：原语不可中断，系统调用执行时允许被中断，甚至有些操作系统中系统进程或系统服务器在用户态运行
>
> 服务的对象不同：通常情况下，原语提供给系统进程或系统服务器使用（反之决不会形成调用关系），系统进程或系统服务器提供系统调用给系统程序（和用户）使用，系统程序提供高层功能给用户使用

**进程管理控制**

>  进程创建
>
> 进程撤销
>
> 进程阻塞与唤醒
>
> 进程挂起和激活

## 2.4线程及其实现

### 2.4.1简单了解线程

线程用于执行包含在进程的地址空间中的代码

进程作为线程的容器，提供线程运行的环境

### 2.4.2引入多线程技术的动机

单线程结构给并发程序设计**效率**带来问题

> 进程切换开销大，进程通信代价大，进程之间并发性粒度较粗，并发度不高

多线程结构

> 在同一进程中设计出多条控制流（每一个控制流称为一个线程），多条控制流之间可以并行执行
>
> 多控制流切换不需要通过进程调度
>
> 多控制流之间还可以通过内存区直接通信，降低通信开销

进程：多个程序并发执行，改善资源利用率和提高系统效率

线程：减少程序并发执行时所付出的时空开销，使得并发粒度更细、并发性更好

> 快速线程切换、通信易于实现、减少管理开销、并发程度高

### 2.4.3多线程环境下的进程和线程

进程控制块PCB|线程控制块TCB

线程是操作系统进程中能够独立执行的实体（控制流）

>  是**处理器调度和分派的基本单位**
>
> 是进程的组成部分，每个进程内允许包含多个并发执行的实体（控制流），这就是多线程
>
> 同一进程中的所有线程共享进程的主存空间和资源，但不拥有资源

**线程属性**

> 结构性：线程具有唯一的标识符和线程控制块，其中包含调度所需的一切私有信息
>
> 共享性：同一进程中的所有线程共享但不拥有进程的状态和资源，且驻留在进程的同一个主存地址空间中，可以访问相同的数据
>
> 动态性：线程是程序在相应数据集上的一次执行过程，由创建而产生，直到由撤消而消亡，有其生命周期。每个进程被创建时，至少同时为其创建一个线程，需要时线程可以再创建其它线程
>
> 并行性：同一进程的多个线程可在一个/多个处理器上并发或并行地执行，而进程之间的并发执行演变为不同进程的线程之间的并发执行

线程状态：运行、就绪和阻塞

==在多线程进程环境下，进程不是调度单位==

线程控制原语

> 孵化（Spawn）：又称创建线程。当一个进程被生成后，该进程的一个线程也被创建。此后，该进程中的一个线程可以孵化同一进程中的其它线程
>
> 封锁（Block）：又称线程阻塞或等待
>
> 活化（Unblock）：又称恢复线程。当被阻塞线程等待的事件发生时，线程变成就绪态或相应状态
>
> 结束（Finish）：又称撤销线程

线程的组织方式：调试员/工作者模式、组模式、流水线模式

从实现的角度看，线程可以分成：

用户级线程、内核级线程、混合式线程

## 2.6处理器调度

### 2.6.1 处理器调度的层次

**处理器有哪三个层次的调度？**

> **高级调度**（作业调度、长程调度）
>
> **中级调度**（内存调度）
>
> **低级调度**
>
> **低级调度**是各类操作系统中**必须具有**的功能

**什么叫高级调度？中级调度？低级调度？**

> **高级调度**发生在新进程的创建中，它决定一个进程能否被创建，或者创建后能否被置成就绪状态
>
> **中级调度**反映到进程状态上就是挂起和解除挂起，它根据系统的当前负荷情况决定停留在主存中进程数
>
> **低级调度**决定哪一个就绪进程占有CPU

### 2.6.2 选择调度算法的原则

**处理器调度算法的选择原则？分别定义**

> **1.资源利用率**
>
> - **CPU利用率** =CPU有效工作时间/CPU总的运行时间
> - **CPU总的运行时间** =CPU有效工作时间+CPU空闲等待时间
>
> **2.吞吐率**
>
> - 单位时间内CPU处理的作业数
>
> **3.公平性**
>
> - 确保每个用户每个进程获得合理的CPU份额或其他资源份额，不会出现饿死情况
>
> **4.响应时间**
>
> 包括三部分时间：
>
> - 请求信息传到处理机的时间
> - 处理机处理请求信息的时间
> - 形成的响应回送到终端的时间
> - **使响应时间尽可能的短，是分时系统衡量调度性能的一个重要指标**
>
> **5.周转时间**
>
> - 批处理用户从作业提交给系统开始，到作业完成为止的时间间隔
> - **使作业周转时间或平均作业周转时间尽可能短，是批处理系统衡量调度性能的一个重要指标**
>
> <img src="https://gitee.com/cpicture/picture-1/raw/master/202109271431544.png" style="zoom: 67%;" />
>
> <img src="https://gitee.com/cpicture/picture-1/raw/master/202109271432987.png" style="zoom:67%;" />
>
> **截止时间**：指某个任务必须开始执行的最迟时间或必须完成的最迟时间，是评价**实时系统调度性能**的一个重要指标 
>
> ~~6.截至时间的保证~~
>
> ~~7.优先权原则~~

### 2.6.3 作业的管理与调度

**作业和进程的关系？**

> 作业是用户提交给操作系统计算的一个独立任务。进程是已提交完毕并选中运行的作业的执行实体，也是为完成作业任务向系统申请和分配资源的基本单位。**作业是任务实体，进程是完成任务的执行实体**。**作业**的概念更多的用于**批处理操作系统**中啊，而**进程**则用于各种**多道程序设计系统**。

**批处理作业的管理和调度步骤？**

> 批处理作业的**输入**
>
> 批处理作业的**建立**
>
> 批处理作业的**调度**
>
> - 选择作业
> - 分配资源
> - 创建进程
> - 作业控制
> - 后续处理

**交互式作业的管理和调度步骤？**

> **交互作业的组织、提交和控制**与批处理作业的差别：
>
> - 生命周期，由用户决定
> - 作业情况和资源需求通过具体命令来提交和控制
> - 输入一条/一组命令，则创建一个/若干进程来完成

### 2.6.4 低级调度功能和类型

**调度程序担负两项任务？**

> **调度**：确定就绪进程/线程使用处理器的次序
>
> **分派**：确定如何时分复用CPU

**低级调度的类型？**

> **剥夺方式**（preemptive），抢占式：
>
> **非剥夺方式**（nonpreemptive），非抢占式：一旦某个进程或线程开始执行后便不再出让处理器，
>
> <img src="https://gitee.com/cpicture/picture-1/raw/master/202109271442220.png" style="zoom: 67%;" />

### 2.6.5 作业调度和低级调度算法

1. FCFS先来先服务

2. SJF最短作业优先

3. SRTF最短剩余时间优先**抢占式**

4. HRRF高响应比优先

   ![image-20211209190054431](https://gitee.com/cpicture/picture-1/raw/master/202112091900483.png)

5. PS优先级调度算法

6. RR时间片转轮算法

# 三、同步、通信和死锁

## 3.1并发进程

### 3.1.1 顺序程序设计

程序内部的顺序性：一个进程只有当一个操作结束后，才能开始后继操作

程序外部的顺序性：完成一个任务需要若干个不同的程序，这些不同程序在时间上按调用次序严格有序执行

顺序程序设计的特点

>  1.程序执行的顺序性
>
>  2.程序环境的封闭性：运行程序独占全部资源
>
> 3.程序执行结果的确定性
>
> 4.计算过程的可再现性

### 3.1.2 进程的并发性

**并发程序设计**：使一个程序分成若干个可同时执行的程序模块的方法称为并发程序设计 (如果这些模块都属于一个进程，在进程内部执行,则称为并发多线程程序设计;若模块属于不同进程,则称为并发多进程程序设计)

**Bernstein条件**

![image-20211209193933659](https://gitee.com/cpicture/picture-1/raw/master/202112091939720.png)

**前驱图**

![image-20211209194118110](https://gitee.com/cpicture/picture-1/raw/master/202112091941177.png)

对于一组交互的并发进程，若执行的相对速度无法相互控制，则各种与时间有关的错误就可能出现

与时间有关的错误有两种表现形式：

> 结果不唯一
>
> 永远等待

### 3.1.3 进程的交互：协作和竞争

资源竞争产生两个问题：

> 死锁(Deadlock)问题，就是一组进程如果都获得了部分资源，还想要得到其他进程所占用的资源，最终所有进程都将陷入死锁
>
> 饥饿(Starvation) 问题，是指一个进程由于其它进程总是优先于它而被无限期拖延

## 3.2 临界区管理

### 3.2.1 互斥与临界区

并发进程中与共享变量有关的程序段叫“临界区” 

共享变量代表的资源叫“临界资源” 

**临界区调度原则**

> 空闲让进
>
> 忙则等待
>
> 有限等待：进程等待进入临界区的时间是有限的，不会发生“饿死”的情况。
>
> 让权等待：进程等待进入临界区时应该放弃CPU的使用。

### 3.2.2 临界区管理的尝试

### 3.2.3软件算法

### 3.2.4硬件设施

用来实现互斥的硬件设施主要有：关中断、测试并建立指令、对换指令

## 3.3信号量与PV操作

### 3.3.1同步与同步机制

操作系统实现进程同步的机制称为同步机制，它通常由 

同步原语组成 

常用的同步机制有： 

> 信号量与PV操作 
>
> 管程 
>
> 进程通信

### 3.3.2信号量与PV操作

**信号量分类**

> 二元信号量
>
> 整型信号量
>
> 结构型信号量：每次只能申请一个
>
> AND型信号量：对于进程在整个运行过程中需要的所有资源， 要么一次性地全部分配给该进程，要么一个也不分 
>
> 信号量集机制

P操作意味着请求一个资源，V操作意味着 释放一个资源；

特定条件下P操作代表挂起进程的操作， V操作代表唤醒被挂起进程的操作

### 3.3.3信号量实现互斥

![image-20211209201621731](https://gitee.com/cpicture/picture-1/raw/master/202112092016792.png)

### 3.3.4哲学家就餐问题

![image-20211209201912596](https://gitee.com/cpicture/picture-1/raw/master/202112092019677.png)

### 3.3.5生产者-消费者问题

## 3.4管程

### 3.4.1管程和条件变量

基本思想：把分散在各个进程中的临界区集中起来管理，并把共享资源用数据结构抽象出来，建立“管程”程序管理到来的访问，每次只让一个进程来访

条件变量：出现在管程内的**全局数据结构**，只能通过两个原语操作来控制它

> wait（）挂起
>
> signal（）释放

## 3.5进程通信

进程通信：进程之间的信息交换

### 3.5.1信号通信机制

信号机制：软中断，进程之间进行通信的简单通信机制

特点：单向的事件通知能力

> 软中断运行在用户态，往往延时较长
>
> 硬中断运行在核心态，可以及时发现

信号的发送：可以由**用户、进程、内核**发送给其他的进程

![image-20211209213039493](https://gitee.com/cpicture/picture-1/raw/master/202112092130554.png)

![image-20211209213102385](https://gitee.com/cpicture/picture-1/raw/master/202112092131433.png)

![image-20211209213211694](https://gitee.com/cpicture/picture-1/raw/master/202112092132747.png)

### 3.5.2管道通信机制

匿名管道：父进程和子进程之间，或同一父进程的两个子进程之间传输数据的无名字的单向管道

命名管道：服务器进程和一个或多个客户进程之间通信的单向或双向管道

![image-20211209213659790](https://gitee.com/cpicture/picture-1/raw/master/202112092136844.png)管道机制应具备的三个协助功能

> 互斥：一次仅有一个进程读写
>
> 确定对方是否存在
>
> 同步。睡眠和唤醒功能

### 3.5.3消息通信机制
![image-20211209214030007](https://gitee.com/cpicture/picture-1/raw/master/202112092140069.png)

消息传递具有进程通信和进程同步的能力

**直接通信方式**

**间接通信方式**：通过信箱

send和receive同步方式

## ![image-20211209214728266](https://gitee.com/cpicture/picture-1/raw/master/202112092147331.png)3.6死锁

### 3.6.1死锁产生

进程推进顺序不当产生 死锁

<img src="https://gitee.com/cpicture/picture-1/raw/master/202112092151682.png" alt="image-20211209215101635" style="zoom: 80%;" />

PV操作使用不当产生死锁

资源分配不当引起死锁

对临时性资源使用不加限制引起死锁

死锁：多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵局状态时，若无外力作用，他们都 将无法再向前推进

死锁产生因素：

> 与系统拥有的资源数量有关
>
> 与资源分配策略有关
>
> 与进程对资源的使用需求以及并发进程的推进顺序有关

### 3.6.2死锁防止

![image-20211209215733152](https://gitee.com/cpicture/picture-1/raw/master/202112092157211.png)

破坏二：静态分配策略

> 一个进程必须在执行前就申请它所要的全部 资源，并且直到它所要的资源都得到满足后才开始执行
>
> 降低了资源利用率,因为每个进程占有的资源中,有些资源
> 在较后的时间里才使用,有些资源在发生例外时才使用

破坏四：层次分配策略

> ![image-20211209220041432](https://gitee.com/cpicture/picture-1/raw/master/202112092200487.png)

### 3.6.3死锁避免

**银行家算法**

![image-20211209220405283](https://gitee.com/cpicture/picture-1/raw/master/202112092204339.png)

**算法缺陷**

> 很难在进程运行前知道其所需的资源最大量
>
> 系统中的进程必须是无关的,相互间没有同步要求
>
> 进程的个数和分配的资源数目应该是固定的

### 3.6.4死锁检测和解除

![image-20211209221335091](https://gitee.com/cpicture/picture-1/raw/master/202112092213143.png)

# ![image-20211209220927048](https://gitee.com/cpicture/picture-1/raw/master/202112092209105.png)四、存储管理

## 4.1存储器

### 4.1.1存储器的层次

<img src="https://gitee.com/cpicture/picture-1/raw/master/202112101025190.png" alt="image-20211210102516068" style="zoom:67%;" />

> 主存（可执行程序）
>
> 高速缓存（L1、L2、L3）
>
> 磁盘缓存-扩展主存

### 4.1.2地址转换与存储保护

**地址转换**

<img src="https://gitee.com/cpicture/picture-1/raw/master/202112101043795.png" alt="image-20211210104310717" style="zoom:67%;" />

动态地址重定位必须借助**硬件**的地址转换机构：地址寄存器以及一些硬件线路实现

## 4.2连续存储空间管理

### 4.2.1固定分区存储管理

**划分**

![image-20211210105521048](https://gitee.com/cpicture/picture-1/raw/master/202112101055106.png)

![image-20211210105601651](https://gitee.com/cpicture/picture-1/raw/master/202112101056699.png)

**地址保护：上下限寄存器**

**缺陷：内碎片、外碎片**

> 限制了程序的大小，程序大小无法超过分区大小
>
> 内存利用率不高
>
> 限制了程序道数
>
> 不便于动态扩展内存

### 4.2.2可变分区存储管理

主存中**分区的数目和大小**随作业的执行不断改变

> 分配->分割->回收
>
> **解决了内碎片问题**，但产生了许多较小的外碎片

可变分区分配算法

![image-20211210162050875](https://gitee.com/cpicture/picture-1/raw/master/202112101620008.png)

![image-20211210162119119](https://gitee.com/cpicture/picture-1/raw/master/202112101621173.png)

![image-20211210162412567](https://gitee.com/cpicture/picture-1/raw/master/202112101624620.png)

### 4.2.3伙伴系统

伙伴系统原理：固定分区和可变分区折中的主存管理算法

![image-20211210162815931](https://gitee.com/cpicture/picture-1/raw/master/202112101628986.png)

### 4.2.4主存不足的存储管理技术

1. 移动技术

   ![image-20211210163000816](https://gitee.com/cpicture/picture-1/raw/master/202112101630863.png)

2. 对换技术

3. 覆盖技术

## 4.3分页式存储管理

### 4.3.1分页式存储的基本原理

![image-20211210163508456](https://gitee.com/cpicture/picture-1/raw/master/202112101635528.png)

**页面大小设置**

> 小：内存碎片减小，内存利用率高；页表过长，占用大量内存
>
> 大：页内碎片增大

**页表**

> 作业离散占有物理块，让系统知道哪个物理页属于哪个作业
>
> 硬件实现：寄存器（造价极高）
>
> 软件实现：需要两次访问内存（指令执行速度降低）

### 4.3.2快表

![image-20211210164531900](https://gitee.com/cpicture/picture-1/raw/master/202112101645956.png)

**命中率计算**

### 4.3.3分页式存储空间的分配和去配

![image-20211210165928691](https://gitee.com/cpicture/picture-1/raw/master/202112101659750.png)

### 4.3.4分页式存储空间的页面共享和保护

分页式存储管理在实现共享时，必须区分数据共享和程序共享

![image-20211210174227572](https://gitee.com/cpicture/picture-1/raw/master/202112101742633.png)

**数据共享：**

### 4.3.5多级页表

### 4.3.6反置页表

## 4.4分段式存储管理

### 4.4.1程序的分段阶段

存储管理技术发展的目标

> 系统准侧：提高系统利用率、
>
> 用户准则：方便用户管理

![image-20211210175243576](https://gitee.com/cpicture/picture-1/raw/master/202112101752638.png)

### 4.4.2分段式存储管理的基本原理

段号+段内偏移

段内连续，段之间不一定连续

![image-20211210175511651](https://gitee.com/cpicture/picture-1/raw/master/202112101755703.png)

### 4.4.3段的共享和保护

![image-20211210175644681](https://gitee.com/cpicture/picture-1/raw/master/202112101756729.png)

### 4.4.4分段和分页的比较

![image-20211210175822586](https://gitee.com/cpicture/picture-1/raw/master/202112101758647.png)

### 4.4.5段页式存储方式

![image-20211210175938496](https://gitee.com/cpicture/picture-1/raw/master/202112101759556.png)

## 4.5虚拟存储管理

### 4.5.1虚拟存储管理的概念

![image-20211210180745927](https://gitee.com/cpicture/picture-1/raw/master/202112101807990.png)

![image-20211210180933934](https://gitee.com/cpicture/picture-1/raw/master/202112101809988.png)

### 4.5.2请求分页虚拟存储管理

内存管理部件MMU提供地址转换和存储保护功能，支持虚拟内存和多任务管理

![image-20211210181705180](https://gitee.com/cpicture/picture-1/raw/master/202112101817247.png)

**页面装入清楚策略**

> 请页式调入：需要访问程序和数据时，才装入；节省主存空间，系统开销大
>
> 预调式调入：系统预测提前调入，一次可调入多页减少磁盘启动次数，节省寻道和搜索时间，多数未使用时效率较低

**页面分配：给一个进程分配多少个物理块**

固定分配

可变分配

**替换粒度：缺页中断时，置换范围局限本进程还是整个内存空间**

局部替换

全局替换

![image-20211210182757982](https://gitee.com/cpicture/picture-1/raw/master/202112101827047.png)

> OPT淘汰最长时间后再访问的页
>
> 不可预测，无法实现
>
> ![image-20211210183212163](https://gitee.com/cpicture/picture-1/raw/master/202112101832220.png)

> LRU最近最少未使用
>
> 实现：双向链表（最常见）、引用位法、计数器法、计时法、寄存器法

# 五、设备管理

![image-20211210193815846](https://gitee.com/cpicture/picture-1/raw/master/202112101938911.png)

![image-20211210194335854](https://gitee.com/cpicture/picture-1/raw/master/202112101943906.png)

## 5.1I/O硬件原理

I/O**系统：**IO设备及其接口电路、控制部件、通道和管理软件的总称

I/O设备分类：

>  特性：输入型、输出型、存储型
>
> 信息交换的单位：字符设备、块设备

### 5.1.2I/O控制方式

**轮询方式**

![image-20211210195022784](https://gitee.com/cpicture/picture-1/raw/master/202112101950849.png)

**中断方式**

![image-20211210195248105](https://gitee.com/cpicture/picture-1/raw/master/202112101952160.png)

> 如果设备控制器的数据缓冲区较小，传送过程中发生中断次数较多，会耗用CPU时间
>
> 多个设备，可能中断次数过多，CPU来不及处理，数据丢失

**DMA方式**

**通道方式**

![image-20211210195904511](https://gitee.com/cpicture/picture-1/raw/master/202112101959581.png)

**通道类型**

> 字节多路通道：一个通道程序相当于一个进程，**顺序执行**
>
> 选择通道（快速设备）：传送一批数据，顺序执行
>
> 数据多路通道（高速设备）：

### 5.1.3设备控制器

**I/O设备包括**

> 电子部件：设备控制器或适配器
>
> 机械部件：设备本身

![image-20211210200551510](https://gitee.com/cpicture/picture-1/raw/master/202112102005574.png)

## 5.2I/O软件原理

### 5.2.1I/O软件的设计目标和原则

![image-20211210200736829](https://gitee.com/cpicture/picture-1/raw/master/202112102007883.png)

### 5.2.2I/O中断处理程序

![image-20211210201027190](https://gitee.com/cpicture/picture-1/raw/master/202112102010245.png)

### 5.2.3I/O设备驱动程序

![image-20211210201146271](https://gitee.com/cpicture/picture-1/raw/master/202112102011327.png)

### 5.2.4独立于设备的I/O软件

![image-20211210201334391](https://gitee.com/cpicture/picture-1/raw/master/202112102013450.png)

### 5.2.5用户空间的I/O软件

![image-20211210201704497](https://gitee.com/cpicture/picture-1/raw/master/202112102017541.png)

## 5.4缓冲技术

![image-20211210201847567](https://gitee.com/cpicture/picture-1/raw/master/202112102018627.png)

### 5.4.1单缓冲

### 5.4.2双缓冲

### 5.4.3多缓冲

## 5.5驱动调试技术

![image-20211210210152462](https://gitee.com/cpicture/picture-1/raw/master/202112102101534.png)

### 5.5.1存储设备的物理结构

顺序存取存储设备：磁带

直接（随机）存取存储设备：磁盘

![image-20211210210458674](https://gitee.com/cpicture/picture-1/raw/master/202112102104736.png)

![image-20211210210758845](https://gitee.com/cpicture/picture-1/raw/master/202112102107906.png)

### 5.5.2循环排序

![image-20211210210738109](https://gitee.com/cpicture/picture-1/raw/master/202112102107181.png)

![image-20211210210829510](https://gitee.com/cpicture/picture-1/raw/master/202112102108573.png)

![image-20211210210843743](https://gitee.com/cpicture/picture-1/raw/master/202112102108804.png)

### 5.5.3优化分布

### 5.5.5搜索定位

1. 先来先服务

2. 最短查找时间

   可能导致饥饿

3. 电梯调度

4. 循环扫描

5. 分布扫描

   每次N个，N个使用电梯调度

   ![image-20211210211542491](https://gitee.com/cpicture/picture-1/raw/master/202112102115552.png)

### 5.5.6独立磁盘冗余阵列

![image-20211210211939037](https://gitee.com/cpicture/picture-1/raw/master/202112102119106.png)

**RAID0**

   > 不存在校验信息，最高利用率，最低安全性

**RAID1**

> 双份数据，

**RAID5**

> 兼顾存储性能、数据安全和存储成本，至少3块磁盘

![image-20211210212356824](https://gitee.com/cpicture/picture-1/raw/master/202112102123893.png)

# 六、文件管理

![image-20211210213615815](https://gitee.com/cpicture/picture-1/raw/master/202112102136878.png)

## 6.1文件

**文件是由文件名字标识的一组信息的集合**

![image-20211210213818608](https://gitee.com/cpicture/picture-1/raw/master/202112102138667.png)

文件属性

> 基本属性：名称、扩展名、所有者
>
> 类型属性：普通文件、系统文件、设备文件、二进制文件
>
> 管理属性：创建时间、最后存取时间、修改时间
>
> 控制属性：
>
> 保护属性：可读、可写、可更新
>
> 访问控制：6535

![image-20211210214340830](https://gitee.com/cpicture/picture-1/raw/master/202112102143896.png)

## 6.2文件目录

![image-20211210214423054](https://gitee.com/cpicture/picture-1/raw/master/202112102144118.png)

**文件控制块FCB**

**文件目录**：FCB集中起来管理；将功能名转换成文件信息在磁盘上的物理位置

### 6.2.2层次目录结构

一级目录结构：存在“命名冲突”

二级目录结构：解决了文件的重名问题和文件共享问题

树形目录结构：

### 6.2.3文件目录的检索

![image-20211210215116641](https://gitee.com/cpicture/picture-1/raw/master/202112102151702.png)

## 6.3文件组织与数据存储

### 6.3.1文件的存储

![image-20211210215203744](https://gitee.com/cpicture/picture-1/raw/master/202112102152800.png)

![image-20211210215240036](https://gitee.com/cpicture/picture-1/raw/master/202112102152095.png)

### 6.3.2文件的逻辑结构

![image-20211210215352503](https://gitee.com/cpicture/picture-1/raw/master/202112102153557.png)

![image-20211210215701360](https://gitee.com/cpicture/picture-1/raw/master/202112102157418.png)

![image-20211210215718803](https://gitee.com/cpicture/picture-1/raw/master/202112102157857.png)

![image-20211210215822557](https://gitee.com/cpicture/picture-1/raw/master/202112102158619.png)

### 6.3.3文件的物理结构

**构造方法：**

> ![image-20211210220051142](https://gitee.com/cpicture/picture-1/raw/master/202112102200207.png)

顺序文件

顺序文件变种：紧凑顺序文件、扩展顺序文件（预设空白区域）、连接顺序文件（设置溢出区）

连接文件（指针）

直接文件

索引文件

## 6.4文件系统其他功能的实现

6.4.1文件系统调用的实现

![image-20211210220544322](https://gitee.com/cpicture/picture-1/raw/master/202112102205381.png)

